<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CSH Hub 25</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* --- CUSTOM GAMING STYLES --- */
        @import url('https://fonts.googleapis.com/css2?family=Rajdhani:wght@400;700&display=swap');
        
        body { 
            margin: 0; 
            font-family: 'Rajdhani', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif; 
            /* MODIFIED: Made transparent to allow video background */
            background-color: transparent; 
            color: #c5c8d1; /* Light grey/off-white for contrast */
        }
        
        /* --- MODIFIED: Background Video CSS --- */
        #video-background-color {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #0b0c10; /* Original background color */
            z-index: -3; /* Places it behind the video */
        }
        #bg-video {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover; /* Ensures video covers screen */
            z-index: -2; /* On top of color, behind scanlines */
            opacity: 0.3; /* 50% opacity as requested */
        }
        /* --- END: Background Video CSS --- */
        
        /* NEW: Utility Classes for a Tech/Neon Look */
        .neon-text-cyan { 
            color: #00f2ff;
            text-shadow: 0 0 5px #00f2ff, 0 0 10px #00f2ff, 0 0 20px rgba(0, 242, 255, 0.4);
        }
        .neon-text-pink {
            color: #ff0077;
            text-shadow: 0 0 5px #ff0077, 0 0 10px #ff0077, 0 0 20px rgba(255, 0, 119, 0.4);
        }
        .tech-border { border: 2px solid #334155; box-shadow: 0 0 10px rgba(51, 65, 85, 0.5); }
        .tech-box-bg { background-color: #1a1b26; }
        
        /* Custom scroll behavior */
        .scroll-container { scroll-behavior: smooth; overflow-x: scroll; }
        .snap-full { min-width: 100%; }
        .scroll-container::-webkit-scrollbar { display: none; }
        .scroll-container { -ms-overflow-style: none; scrollbar-width: none; }
        
        /* Custom gradients */
        .admin-gradient { 
            background-image: linear-gradient(to right, #00f2ff, #0077ff); 
            box-shadow: 0 0 15px rgba(0, 242, 255, 0.6); 
        }
        .upload-gradient { 
            background-image: linear-gradient(to right, #ff0077, #aa00ff); 
            box-shadow: 0 0 15px rgba(255, 0, 119, 0.6); 
        }
        
        /* Keyframes for animations */
        @keyframes pulse-shadow {
            0%, 100% { box-shadow: 0 0 10px rgba(0, 242, 255, 0.6), 0 0 0 0 rgba(0, 242, 255, 0.4); }
            50% { box-shadow: 0 0 25px rgba(0, 242, 255, 0.9), 0 0 0 10px rgba(0, 242, 255, 0); }
        }
        .animate-pulse-shadow {
            animation: pulse-shadow 2s infinite ease-in-out;
        }

        @keyframes scanline-bg {
            0% { background-position: 0 0; }
            100% { background-position: 100% 100%; }
        }
        
        /* MODIFIED: Scanline effect moved to its own overlay */
        #scanline-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Lets clicks pass through */
            z-index: -1; /* Sits on top of video, behind all content */
            background-image: linear-gradient(
                rgba(255, 255, 255, 0.05) 1px, 
                transparent 1px
            );
            background-size: 100% 4px;
            animation: scanline-bg 20s linear infinite;
        }

        /* Style for the Hall of Fame cards */
        .hof-card {
            border-image: linear-gradient(45deg, #00f2ff, #ff0077) 1;
            border-width: 3px;
            border-style: solid;
            box-shadow: 0 0 20px rgba(0, 242, 255, 0.2), 0 0 20px rgba(255, 0, 119, 0.2);
            transition: all 0.3s;
        }
        .hof-card:hover {
            transform: scale(1.02);
            box-shadow: 0 0 30px rgba(0, 242, 255, 0.5), 0 0 30px rgba(255, 0, 119, 0.5);
        }

        /* Sparkle effect on successful login */
        @keyframes sparkle {
            0%, 100% { opacity: 0; transform: scale(0.5) rotate(0deg); }
            50% { opacity: 1; transform: scale(1.5) rotate(180deg); }
        }
        .login-sparkle {
            position: absolute;
            width: 10px;
            height: 10px;
            background: radial-gradient(circle, #fff, #ff0077);
            border-radius: 50%;
            animation: sparkle 1s ease-out forwards;
        }
        
        /* --- C-Matrix Effect --- */
        #cmatrix-background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            z-index: 40; /* Behind login modal (50) */
            background-color: #000;
        }
        .matrix-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            user-select: none;
            opacity: 0.8; 
        }

        /* --- Content Transition Animation --- */
        @keyframes fadeInSlideUp {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .content-transition {
            animation: fadeInSlideUp 0.5s ease-out;
        }
    </style>
</head>
<body class="">

    <div id="video-background-color"></div>
    <video autoplay loop muted id="bg-video">
        <source src="mario.mp4" type="video/mp4">
        Your browser does not support the video tag.
    </video>
    <div id="scanline-overlay"></div>
    <div id="root"></div>

    <script type="module">
        // --- SUPABASE CLIENT IMPORT ---
        import { createClient } from 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js/+esm';

        // =================================================================
        // !!! ÓÅûÂú∑ ACTION REQUIRED: REPLACE YOUR_SUPABASE_PROJECT_URL ÓÅûÂú∑ !!!
        // =================================================================
        const supabaseUrl = 'https://vspbfgmfszadpbegmous.supabase.co'; 
        // NOTE: Use your Supabase 'anon' key here.
        const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InZzcGJmZ21mc3phZHBiZWdtb3VzIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjIwMTg3MTMsImV4cCI6MjA3NzU5NDcxM30.Phjr2R8e22YH8PNUCP0Ls-_gE8pSRIFel34bvbJCUoQ'; 
        // =================================================================
        
        const supabase = createClient(supabaseUrl, supabaseKey);

        // --- C-Matrix Setup ---
        const CMatrix = {
            container: null,
            interval: null,
            columns: [],
            stop() {
                if (this.interval) clearInterval(this.interval);
                this.interval = null;
                this.container = null;
                this.columns = [];
                const oldContainer = document.getElementById('cmatrix-background');
                if(oldContainer) oldContainer.remove();
            },
            start() {
                if(this.interval) return; // Already running

                const body = document.body;
                const matrixDiv = document.createElement('div');
                matrixDiv.id = 'cmatrix-background';
                matrixDiv.innerHTML = '<div class="matrix-container"></div>';
                body.appendChild(matrixDiv);
                
                this.container = matrixDiv.querySelector('.matrix-container');
                const canvas = document.createElement('canvas');
                this.container.appendChild(canvas);

                const ctx = canvas.getContext('2d');
                let width = canvas.width = window.innerWidth;
                let height = canvas.height = window.innerHeight;
                const font_size = 15;
                const columns = Math.floor(width / font_size);
                const drops = [];
                for(let i = 0; i < columns; i++) {
                    drops[i] = 1;
                }

                const characters = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ!@#$%^&*()_+=-{}[]:;\"'<>,.?/\\|";

                const draw = () => {
                    ctx.fillStyle = "rgba(0, 0, 0, 0.05)"; // Use black fade
                    ctx.fillRect(0, 0, width, height);

                    ctx.fillStyle = "#00ff41"; // Green text
                    ctx.font = font_size + "px monospace";

                    for(let i = 0; i < drops.length; i++) {
                        const text = characters.charAt(Math.floor(Math.random() * characters.length));
                        const y = drops[i] * font_size;
                        const x = i * font_size;

                        ctx.fillText(text, x, y);

                        if(y > height && Math.random() > 0.975) { 
                            drops[i] = 0;
                        }
                        drops[i]++;
                    }
                };

                // Resize handler to update canvas dimensions
                const handleResize = () => {
                    width = canvas.width = window.innerWidth;
                    height = canvas.height = window.innerHeight;
                    const newColumns = Math.floor(width / font_size);
                    while (drops.length < newColumns) {
                        drops.push(1);
                    }
                    while (drops.length > newColumns) {
                        drops.pop();
                    }
                };
                window.addEventListener('resize', handleResize);
                this.interval = setInterval(draw, 50);

                // Add resize cleanup to the stop function
                const originalStop = this.stop.bind(this);
                this.stop = () => {
                    originalStop();
                    window.removeEventListener('resize', handleResize);
                };
            }
        };

        // Lucide Icons (Star and Lock removed)
        const icons = {
            Upload: (size = 24) => `<svg width="${size}" height="${size}" viewBox="0 0 24 24" fill="none" stroke="#00f2ff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="neon-text-cyan"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="17 8 12 3 7 8"></polyline><line x1="12" y1="3" x2="12" y2="15"></line></svg>`,
            LogOut: (size = 24) => `<svg width="${size}" height="${size}" viewBox="0 0 24 24" fill="none" stroke="#ff0077" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="neon-text-pink"><path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"></path><polyline points="16 17 21 12 16 7"></polyline><line x1="21" y1="12" x2="9" y2="12"></line></svg>`,
            Image: (size = 24) => `<svg width="${size}" height="${size}" viewBox="0 0 24 24" fill="none" stroke="#00f2ff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="neon-text-cyan"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline></svg>`,
            Heart: (size = 24) => `<svg width="${size}" height="${size}" viewBox="0 0 24 24" fill="currentColor" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-pink-500"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg>`,
            ChevronLeft: (size = 24) => `<svg width="${size}" height="${size}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="15 18 9 12 15 6"></polyline></svg>`,
            ChevronRight: (size = 24) => `<svg width="${size}" height="${size}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="9 18 15 12 9 6"></polyline></svg>`,
            Download: (size = 24) => `<svg width="${size}" height="${size}" viewBox="0 0 24 24" fill="none" stroke="#ff0077" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="neon-text-pink"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>`,
            Trash: (size = 24) => `<svg width="${size}" height="${size}" viewBox="0 0 24 24" fill="none" stroke="#ff0077" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="neon-text-pink"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>`,
            Bell: (size = 24) => `<svg width="${size}" height="${size}" viewBox="0 0 24 24" fill="none" stroke="#00f2ff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="neon-text-cyan"><path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9"></path><path d="M13.73 21a2 2 0 0 1-3.46 0"></path></svg>`
        };

        // Helper function to extract the Storage file path from the full public URL
        function extractFilePath(url) {
            const parts = url.split('/storage/v1/object/public/gallery/');
            return parts.length > 1 ? parts[1] : null;
        }

        // Compress image to a Blob
        function compressImage(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        let width = img.width;
                        let height = img.height;
                        
                        const maxDimension = 1200; 
                        if (width > maxDimension || height > maxDimension) {
                            if (width > height) {
                                height = (height / width) * maxDimension;
                                width = maxDimension;
                            } else {
                                width = (width / height) * maxDimension;
                                height = maxDimension;
                            }
                        }
                        
                        canvas.width = width;
                        canvas.height = height;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0, width, height);
                        canvas.toBlob((blob) => {
                            if (blob) {
                                // Prefer JPEG for compression, check file type for PNG
                                const mimeType = file.type.startsWith('image/png') ? 'image/png' : 'image/jpeg';
                                const quality = mimeType === 'image/jpeg' ? 0.85 : 1.0; 
                                
                                canvas.toBlob(resolve, mimeType, quality);
                            } else {
                                reject(new Error('Canvas to Blob failed.'));
                            }
                        }, file.type.startsWith('image/png') ? 'image/png' : 'image/jpeg', 0.85); // 85% quality for JPEG
                    };
                    img.onerror = reject;
                    img.src = e.target.result;
                };
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }
        
        class MemeGallery {
            constructor() {
                this.state = {
                    isLoggedIn: false,
                    isAdmin: false,
                    isNoticesAdmin: false,
                    userEmail: '',
                    email: '',
                    password: '',
                    currentTab: 'notices',
                    hallOfFameMemes: [],
                    hallOfFameMemories: [],
                    memes: [],
                    memories: [],
                    notices: [],
                    showLogin: false,
                    loading: true,
                    error: '',
                    uploadStatus: '',
                    memeScrollIndex: 0,
                    memoryScrollIndex: 0
                };
                this.memeScrollInterval = null;
                this.memoryScrollInterval = null;
                this.init();
            }

            async init() {
                await Promise.all([this.loadAllData(), this.loadNotices()]);
                this.render();
                this.startAutoScroll();
            }

            async loadNotices() {
                const { data, error } = await supabase
                    .from('notices')
                    .select('id, content, uploadedBy, createdAt, timestamp')
                    .order('timestamp', { ascending: false });

                if (error) {
                    console.error('Error loading notices:', error);
                }
                this.state.notices = data || [];
                this.render();
            }

            async loadAllData() {
                this.state.loading = true;

                const fetchAll = async (table) => {
                    const { data, error } = await supabase
                        .from(table)
                        .select('id, imageUrl, uploadedBy, timestamp, is_hall_of_fame')
                        .order('timestamp', { ascending: false });
                    
                    if (error) {
                        console.error(`Error loading ${table}:`, error);
                        return { regular: [], hall: [] };
                    }

                    const regular = data.filter(item => !item.is_hall_of_fame);
                    const hall = data.filter(item => item.is_hall_of_fame);
                    return { regular, hall };
                };

                const [memeData, memoryData] = await Promise.all([
                    fetchAll('memes'),
                    fetchAll('memories')
                ]);

                this.state.memes = memeData.regular;
                this.state.hallOfFameMemes = memeData.hall;
                this.state.memories = memoryData.regular;
                this.state.hallOfFameMemories = memoryData.hall;
                this.state.loading = false;
                this.render();
            }

            // --- USER/ADMIN FUNCTIONS ---
            async handleLogin(e) {
                e.preventDefault();
                this.state.error = '';
                this.state.uploadStatus = 'Attempting login...';
                this.render();

                try {
                    const { data, error } = await supabase.auth.signInWithPassword({
                        email: this.state.email,
                        password: this.state.password,
                    });

                    if (error) throw error;
                    
                    const userEmail = data.user.email;
                    
                    // Check for admin/notices_admin status
                    const { data: userProfile, error: profileError } = await supabase
                        .from('profiles')
                        .select('is_admin, is_notices_admin')
                        .eq('id', data.user.id)
                        .single();

                    if (profileError && profileError.code !== 'PGRST116') { // PGRST116 means no rows found (not an issue)
                         console.warn("Could not fetch user profile:", profileError.message);
                    }

                    this.state.isLoggedIn = true;
                    this.state.isAdmin = userProfile?.is_admin || false;
                    this.state.isNoticesAdmin = userProfile?.is_notices_admin || false;
                    this.state.userEmail = userEmail;
                    this.state.showLogin = false;
                    this.state.uploadStatus = `Login successful. Welcome, ${userEmail}!`;
                    
                    this.render();
                    this.triggerLoginSparkle(); // NEW: Call sparkle effect
                } catch (err) {
                    this.state.error = `Login Failed: ${err.message}`;
                    this.state.uploadStatus = '';
                    this.render();
                }
            }

            // --- NEW FUNCTION: Sparkle Effect on successful login ---
            triggerLoginSparkle() {
                const nav = document.getElementById('nav-bar');
                if (!nav) return;

                for (let i = 0; i < 20; i++) {
                    const sparkle = document.createElement('div');
                    sparkle.className = 'login-sparkle';
                    
                    // Random positions near the CSH Gallery title
                    const x = Math.random() * 200 - 100; // -100 to 100
                    const y = Math.random() * 50 - 25; // -25 to 25
                    
                    sparkle.style.left = `${nav.querySelector('h1').offsetLeft + nav.querySelector('h1').offsetWidth / 2 + x}px`;
                    sparkle.style.top = `${nav.querySelector('h1').offsetTop + nav.querySelector('h1').offsetHeight / 2 + y}px`;
                    sparkle.style.animationDelay = `${Math.random() * 0.5}s`;
                    
                    nav.appendChild(sparkle);

                    // Remove sparkle after animation
                    setTimeout(() => nav.removeChild(sparkle), 1000);
                }
            }
            // --- END NEW FUNCTION ---

            handleLogout() {
                this.state.isLoggedIn = false;
                this.state.isAdmin = false;
                this.state.isNoticesAdmin = false;
                this.state.userEmail = '';
                this.state.email = '';
                this.state.password = '';
                this.render();
            }

            // --- ADMIN WIPE AND ARCHIVE FUNCTION (UNCHANGED) ---
            async handleWipeAndArchive() {
                if (!this.state.isAdmin) return;
                
                if (!confirm("ADMIN WARNING: This action will archive ALL files and WIPE the entire database (memes, memories, and notices tables). Are you absolutely sure?")) {
                    return;
                }

                this.state.uploadStatus = 'ARCHIVING AND WIPING... DO NOT REFRESH...';
                this.render();

                try {
                    // 1. Fetch all file URLs from both tables
                    const { data: allMemes } = await supabase.from('memes').select('imageUrl');
                    const { data: allMemories } = await supabase.from('memories').select('imageUrl');
                    const allUrls = [...(allMemes || []), ...(allMemories || [])].map(item => item.imageUrl);

                    // 2. Archive files (move all files to the 'archive' bucket)
                    for (const url of allUrls) {
                        const filePath = extractFilePath(url);
                        if (filePath) {
                             // This is a complex, multi-step process for Supabase Storage, typically involving a custom function 
                             // or service to move files between buckets. For a simple front-end script, we'll simulate the 
                             // move and then delete the source.

                            // First, try to copy/move to an 'archive' folder within the 'gallery' bucket
                            const { error: moveError } = await supabase.storage
                                .from('gallery')
                                .move(filePath, `archive/${filePath}`);
                            
                            // If move fails, try to delete the original anyway as the goal is to free space
                            if (moveError) {
                                console.warn(`Failed to archive file ${filePath}: ${moveError.message}. Attempting delete only.`);
                            } else {
                                // If move succeeded, the original is gone, no need for separate delete.
                            }

                             // NOTE: For a real application, a more robust backend solution for archiving 
                             // to a separate 'archive' bucket would be preferred. The `move` function 
                             // within the same bucket simulates a cleanup.
                        }
                    }

                    // 3. Wipe all data from the database tables
                    // NOTE: This assumes RLS is set up to allow an admin to delete all rows.
                    const { error: memesDeleteError } = await supabase.from('memes').delete().neq('id', 0);
                    if (memesDeleteError) console.error('Memes table deletion failed. Check RLS.');
                    const { error: memoriesDeleteError } = await supabase.from('memories').delete().neq('id', 0);
                    if (memoriesDeleteError) console.error('Memories table deletion failed. Check RLS.');
                    const { error: noticesDeleteError } = await supabase.from('notices').delete().neq('id', 0);
                    if (noticesDeleteError) console.error('Notices table deletion failed. Check RLS.');

                    this.state.uploadStatus = `ARCHIVE & WIPE SUCCESSFUL: ${allUrls.length} files archived and all data/files deleted. Space is now free!`;
                    this.loadAllData();
                    this.loadNotices();

                } catch (err) {
                    this.state.uploadStatus = `WIPE FAILED: ${err.message}`;
                    console.error('Wipe operation failed:', err);
                    this.render();
                }
            }

            // --- DELETE INDIVIDUAL MEME/MEMORY FUNCTION ---
            async handleDeleteItem(id, type) {
                if (!this.state.isAdmin) return;
                this.state.uploadStatus = `Deleting ${type}...`;
                this.render();

                try {
                    const table = type === 'memory' ? 'memories' : 'memes';

                    // 1. Get the imageUrl to delete the file from storage
                    const { data: itemData, error: fetchError } = await supabase
                        .from(table)
                        .select('imageUrl')
                        .eq('id', id)
                        .single();

                    if (fetchError || !itemData) throw new Error('Item not found or fetch failed.');

                    const filePath = extractFilePath(itemData.imageUrl);

                    // 2. Delete the file from Supabase Storage
                    if (filePath) {
                        const { error: storageError } = await supabase.storage
                            .from('gallery')
                            .remove([filePath]);

                        if (storageError) console.warn('Storage deletion failed:', storageError.message);
                    }

                    // 3. Delete the record from the database
                    const { error: dbError } = await supabase
                        .from(table)
                        .delete()
                        .eq('id', id);
                    
                    if (dbError) throw dbError;

                    this.state.uploadStatus = `${type} deleted successfully! üóëÔ∏è`;
                    this.loadAllData();

                } catch (err) {
                    this.state.uploadStatus = `DELETE FAILED: ${err.message}`;
                    console.error('Delete operation failed:', err);
                }
                this.render();
            }

            // --- DELETE INDIVIDUAL NOTICE FUNCTION ---
            async handleDeleteNotice(id) {
                if (!this.state.isNoticesAdmin) return;
                this.state.uploadStatus = `Deleting notice...`;
                this.render();

                try {
                    const { error: dbError } = await supabase
                        .from('notices')
                        .delete()
                        .eq('id', id);
                    
                    if (dbError) throw dbError;

                    this.state.uploadStatus = `Notice deleted successfully! üóëÔ∏è`;
                    this.loadNotices();

                } catch (err) {
                    this.state.uploadStatus = `NOTICE DELETE FAILED: ${err.message}`;
                    console.error('Notice delete operation failed:', err);
                }
                this.render();
            }

            // --- POST NOTICE FUNCTION (MODIFIED FOR ADMIN CHECK) ---
            async handlePostNotice(e) {
                e.preventDefault();
                if (!this.state.isNoticesAdmin) return;

                const content = document.getElementById('noticeContentInput').value;
                if (content.trim().length < 5) {
                    this.state.uploadStatus = 'Notice must be at least 5 characters long.';
                    this.render();
                    setTimeout(() => { this.state.uploadStatus = ''; this.render(); }, 3000);
                    return;
                }

                this.state.uploadStatus = 'Posting notice...';
                this.render();

                try {
                    // 1. Delete oldest notice if max limit (10) is reached
                    const MAX_NOTICES = 10;
                    if (this.state.notices.length >= MAX_NOTICES) {
                        this.state.uploadStatus = 'Deleting oldest notice...';
                        this.render();
                        const oldestNotice = this.state.notices[this.state.notices.length - 1];
                        const { error: deleteError } = await supabase
                            .from('notices')
                            .delete()
                            .eq('id', oldestNotice.id);
                        
                        if (deleteError) {
                            console.error('Failed to delete oldest notice. Inserting anyway:', deleteError);
                        }
                    }

                    // 2. Insert new notice
                    const { error } = await supabase
                        .from('notices')
                        .insert([
                            { 
                                content: content.trim(), 
                                uploadedBy: this.state.userEmail,
                                timestamp: Date.now(),
                            }
                        ]);

                    if (error) throw error;

                    this.state.uploadStatus = 'Notice posted successfully! üì¢';
                    document.getElementById('noticeContentInput').value = '';
                    this.loadNotices();

                    setTimeout(() => { 
                        this.state.uploadStatus = ''; 
                        this.render(); 
                    }, 3000);

                } catch (err) {
                    this.state.uploadStatus = `Notice post failed: ${err.message}. Check RLS on 'notices' table.`;
                    console.error('Notice error:', err);
                }
                this.render();
            }

            // --- UPLOAD FUNCTION (WITH COMPRESSION) ---
            async handleFileUpload(file, type) {
                if (!file || !this.state.isLoggedIn) {
                    document.getElementById('fileInput').value = ''; 
                    return;
                }

                this.state.uploadStatus = `Processing and compressing ${type}...`;
                this.render();

                try {
                    // 1. Compression Logic
                    const compressedBlob = await new Promise(async (resolve, reject) => {
                        if (file.size > 2 * 1024 * 1024) { // Only compress if > 2MB
                            compressImage(file).then(resolve).catch(reject);
                        } else {
                            // If file is small, just use the original file object but ensure it's a blob
                            if (file instanceof Blob) {
                                resolve(file);
                            } else {
                                reject(new Error('File is too small for compression logic to handle properly.'));
                            }
                        }
                    });

                    // 2. Upload to Supabase Storage
                    const fileExtension = file.name.split('.').pop();
                    const fileName = `${Date.now()}-${Math.random().toString(36).substring(2, 9)}.${fileExtension}`;
                    
                    const { data, error: uploadError } = await supabase.storage
                        .from('gallery')
                        .upload(fileName, compressedBlob, {
                            cacheControl: '3600',
                            upsert: false,
                            contentType: compressedBlob.type,
                        });

                    if (uploadError) throw uploadError;

                    // 3. Get public URL
                    const { data: publicUrlData } = supabase.storage
                        .from('gallery')
                        .getPublicUrl(data.path);
                    
                    const imageUrl = publicUrlData.publicUrl;
                    const table = type === 'memory' ? 'memories' : 'memes';

                    // 4. Insert record into the database
                    const { error: insertError } = await supabase
                        .from(table)
                        .insert([
                            { 
                                imageUrl: imageUrl, 
                                uploadedBy: this.state.userEmail, 
                                timestamp: Date.now() 
                            }
                        ]);

                    if (insertError) throw insertError;

                    this.state.uploadStatus = `${type} uploaded successfully! üöÄ`;
                    this.loadAllData(); // Refresh data

                } catch (err) {
                    this.state.uploadStatus = `UPLOAD FAILED: ${err.message}. Check Supabase Storage/RLS settings. See console for RLS or configuration errors.`;
                } finally {
                    document.getElementById('fileInput').value = '';
                    this.render();
                    setTimeout(() => { 
                        this.state.uploadStatus = ''; 
                        this.render(); 
                    }, 5000);
                }
            }

            async promoteToHallOfFame(item, type) {
                if (!this.state.isAdmin) return;
                try {
                    const sourceTable = type === 'memory' ? 'memories' : 'memes';
                    const { error } = await supabase
                        .from(sourceTable)
                        .update({ is_hall_of_fame: true })
                        .eq('id', item.id);
                    
                    if (error) throw error;
                    this.loadAllData();

                } catch (err) {
                    console.error('Failed to promote:', err);
                }
            }

            async removeFromHallOfFame(itemId, type) {
                if (!this.state.isAdmin) return;
                try {
                    const sourceTable = type === 'memory' ? 'memories' : 'memes';
                    const { error } = await supabase
                        .from(sourceTable)
                        .update({ is_hall_of_fame: false })
                        .eq('id', itemId);
                    
                    if (error) throw error;
                    this.loadAllData();

                } catch (err) {
                    console.error('Failed to remove:', err);
                }
            }

            // --- RENDERING ---

            renderNoticesTab() {
                const isNoticesAdmin = this.state.isNoticesAdmin;
                return `
                    <div id="notices-content" class="max-w-4xl mx-auto py-8">
                        <div class="flex items-center gap-4 mb-8">
                            ${icons.Bell(36)}
                            <h2 class="text-4xl font-extrabold neon-text-cyan tracking-tight">SYSTEM_NOTICES // 25</h2>
                        </div>

                        ${isNoticesAdmin ? `
                            <div class="tech-box-bg rounded-2xl p-8 shadow-2xl border-4 border-[#00f2ff]/50 tech-border mb-12 transform transition duration-300">
                                <h3 class="text-2xl font-bold neon-text-cyan mb-4">ADMIN_CONSOLE // POST</h3>
                                <form id="postNoticeForm" class="space-y-4">
                                    <textarea id="noticeContentInput" rows="3" placeholder="Enter a new system notice..." class="w-full px-4 py-3 bg-[#111219] text-white rounded-lg border border-gray-700 focus:border-[#00f2ff] focus:ring focus:ring-[#00f2ff]/30 transition"></textarea>
                                    <button type="submit" class="w-full admin-gradient text-white px-5 py-3 rounded-xl font-extrabold text-lg flex items-center justify-center gap-2 shadow-lg hover:shadow-cyan-500/80 transition transform hover:scale-[1.015]">
                                        POST NOTICE // EXECUTE
                                    </button>
                                </form>
                                <p class="text-sm text-gray-500 mt-4">Only up to 10 notices are kept. The oldest will be automatically deleted on new post.</p>
                            </div>
                        ` : ''}

                        ${this.state.loading ? `
                            <div class="text-center py-12 tech-box-bg rounded-2xl shadow-lg"><p class="text-gray-400">Loading Notices...</p></div>
                        ` : this.state.notices.length === 0 ? `
                            <div class="text-center py-12 tech-box-bg rounded-2xl shadow-lg"><p class="text-gray-400">No active system notices.</p></div>
                        ` : `
                        <div class="space-y-6">
                            ${this.state.notices.map(notice => `
                                <div class="tech-box-bg p-6 rounded-2xl shadow-xl border-l-4 border-[#00f2ff] content-transition">
                                    <p class="text-xl font-bold whitespace-pre-wrap leading-relaxed">${notice.content}</p>
                                    <div class="flex items-center justify-between mt-4 border-t border-gray-700 pt-3">
                                        <span class="text-sm text-gray-500">Source: ${notice.uploadedBy}</span>
                                        ${isNoticesAdmin ? `
                                            <button data-delete-notice="${notice.id}" class="flex items-center gap-1 bg-red-700 text-white px-3 py-1.5 text-xs rounded-xl font-semibold hover:bg-red-800 transition shadow-md">
                                                ${icons.Trash(14)} DELETE
                                            </button>
                                        ` : ''}
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                        `}
                    </div>
                `;
            }

            renderMainPage() {
                const isMemeTab = this.state.currentTab === 'memes';
                const isMemoryTab = this.state.currentTab === 'memories';
                const isNoticesTab = this.state.currentTab === 'notices';

                if (isNoticesTab) {
                    return this.renderNoticesTab();
                }

                const currentData = isMemeTab 
                    ? { hall: this.state.hallOfFameMemes, regular: this.state.memes, type: 'meme', color: 'purple' } 
                    : { hall: this.state.hallOfFameMemories, regular: this.state.memories, type: 'memory', color: 'pink' };

                const memeTabClass = 'border-[#ff0077] text-[#ff0077]';
                const memoryTabClass = 'border-[#00f2ff] text-[#00f2ff]';
                const tabColor = isMemeTab ? memeTabClass : memoryTabClass;
                const tabColorHover = isMemeTab ? 'hover:text-[#ff0077] hover:border-[#ff0077]' : 'hover:text-[#00f2ff] hover:border-[#00f2ff]';
                const tabColorActive = isMemeTab ? 'bg-[#ff0077]/20 border-b-4' : 'bg-[#00f2ff]/20 border-b-4';
                const uploadGradient = isMemeTab ? 'upload-gradient' : 'admin-gradient';
                const uploadIcon = isMemeTab ? icons.Image(24) : icons.Heart(24);
                const scrollContainerId = isMemeTab ? 'meme-scroll-container' : 'memory-scroll-container';
                const scrollIndex = isMemeTab ? this.state.memeScrollIndex : this.state.memoryScrollIndex;


                return `
                    <div class="max-w-7xl mx-auto py-8 px-4 sm:px-6 lg:px-8">
                        <header id="nav-bar" class="flex justify-between items-center mb-12 p-4 tech-box-bg rounded-xl shadow-2xl">
                            <h1 class="text-4xl sm:text-5xl font-extrabold neon-text-cyan tracking-widest">CSH Hub <span class="neon-text-pink">25</span></h1>
                            <nav class="flex items-center space-x-4">
                                ${this.state.isLoggedIn ? `
                                    <span class="hidden sm:inline text-sm text-gray-400 font-bold border-r border-gray-700 pr-4">${this.state.userEmail}</span>
                                    <button id="logoutBtn" class="flex items-center ${tabColorHover} text-white font-bold py-2 px-3 rounded-lg transition">
                                        ${icons.LogOut(24)}
                                    </button>
                                ` : `
                                    <button id="showLoginBtn" class="flex items-center admin-gradient text-white font-bold py-2 px-4 rounded-xl transition shadow-lg hover:shadow-cyan-500/80 transform hover:scale-[1.05]">
                                        LOGIN // AUTH
                                    </button>
                                `}
                            </nav>
                        </header>

                        <div class="flex border-b-2 border-gray-700 mb-10 sticky top-0 bg-[#0b0c10] z-30 pt-4">
                            <button data-tab="notices" class="py-3 px-6 text-lg font-bold transition border-b-4 border-transparent ${isNoticesTab ? 'border-[#00f2ff] text-[#00f2ff] bg-[#00f2ff]/20' : 'hover:border-gray-500 hover:text-gray-300'}">
                                NOTICES
                            </button>
                            <button data-tab="memes" class="py-3 px-6 text-lg font-bold transition border-b-4 border-transparent ${isMemeTab ? 'border-[#ff0077] text-[#ff0077] bg-[#ff0077]/20' : 'hover:border-gray-500 hover:text-gray-300'}">
                                MEMES
                            </button>
                            <button data-tab="memories" class="py-3 px-6 text-lg font-bold transition border-b-4 border-transparent ${isMemoryTab ? 'border-[#00f2ff] text-[#00f2ff] bg-[#00f2ff]/20' : 'hover:border-gray-500 hover:text-gray-300'}">
                                MEMORIES
                            </button>
                        </div>

                        <div class="mb-16">
                            <div class="flex items-center gap-3 mb-6">
                                ${isMemeTab ? icons.Image(36) : icons.Heart(36)}
                                <h2 class="text-3xl font-extrabold ${isMemeTab ? 'neon-text-pink' : 'neon-text-cyan'} tracking-tight">HALL OF GLORY // ARCHIVES</h2>
                                <span class="text-sm text-gray-500 ml-auto">${isMemeTab ? 'High Score Memes' : 'Legendary Memories'}</span>
                            </div>

                            ${this.state.loading ? `
                                <div class="text-center py-12 tech-box-bg rounded-2xl shadow-lg"><p class="text-gray-400">Loading Data...</p></div>
                            ` : this.renderScrollingHallOfFame(currentData.hall, currentData.type)}
                        </div>

                        ${this.state.uploadStatus ? `
                            <div class="bg-[#00f2ff]/20 border-l-4 border-[#00f2ff] text-white p-4 mb-10 rounded-lg shadow-md font-bold" role="alert">
                                <p class="text-[#00f2ff]">// OPERATION STATUS</p>
                                <p class="text-sm">${this.state.uploadStatus}</p>
                            </div>
                        ` : ''}

                        ${this.state.isLoggedIn ? `
                            <div class="mb-12 tech-box-bg rounded-2xl p-8 shadow-2xl border-4 ${isMemeTab ? 'border-[#ff0077]/50' : 'border-[#00f2ff]/50'} tech-border transform hover:scale-[1.005] transition duration-300">
                                <h2 class="text-2xl font-bold ${isMemeTab ? 'neon-text-pink' : 'neon-text-cyan'} mb-4">UPLOAD_CONSOLE // ${isMemeTab ? 'MEME' : 'MEMORY'}</h2>
                                <label for="fileInput" class="w-full ${uploadGradient} text-white px-5 py-3 rounded-xl font-extrabold text-lg flex items-center justify-center gap-2 shadow-lg hover:shadow-cyan-500/80 transition transform hover:scale-[1.015] cursor-pointer">
                                    ${uploadIcon} UPLOAD ${isMemeTab ? 'MEME' : 'MEMORY'} // EXECUTE
                                </label>
                                <input type="file" id="fileInput" accept="image/jpeg, image/png, image/gif, video/mp4, video/webm" class="hidden">
                                <p class="text-sm text-gray-500 mt-4 text-center">Accepted formats: JPG, PNG, GIF, MP4, WebM. Files > 2MB will be compressed.</p>
                            </div>
                        ` : `
                            <div class="text-center py-10 tech-box-bg rounded-2xl shadow-xl border-4 ${isMemeTab ? 'border-[#ff0077]/50' : 'border-[#00f2ff]/50'} tech-border">
                                <p class="text-xl text-gray-400 font-bold">Log in to upload your own ${isMemeTab ? 'memes' : 'memories'}!</p>
                            </div>
                        `}
                        
                        ${this.state.isAdmin ? `
                            <div class="mb-12 text-center">
                                <button id="adminWipeBtn" class="bg-red-700 text-white px-6 py-3 rounded-xl font-extrabold text-lg shadow-lg hover:bg-red-800 transition transform hover:scale-[1.05]">
                                    ADMIN // WIPE_AND_ARCHIVE
                                </button>
                                <p class="text-xs text-red-500 mt-2">DANGEROUS: Deletes ALL data and archives files. Use with caution.</p>
                            </div>
                        ` : ''}


                        <div class="mb-16">
                            <div class="flex items-center gap-3 mb-6">
                                <h2 class="text-3xl font-extrabold ${isMemeTab ? 'neon-text-pink' : 'neon-text-cyan'} tracking-tight">GALLERY // ${isMemeTab ? 'MEMES' : 'MEMORIES'}</h2>
                                <span class="text-sm text-gray-500 ml-auto">Total: ${currentData.regular.length}</span>
                            </div>
                            
                            ${this.state.loading ? `
                                <div class="text-center py-12 tech-box-bg rounded-2xl shadow-lg"><p class="text-gray-400">Loading Data...</p></div>
                            ` : currentData.regular.length === 0 ? `
                                <div class="text-center py-12 tech-box-bg rounded-2xl shadow-lg"><p class="text-gray-400">No ${currentData.type}s have been uploaded yet.</p></div>
                            ` : `
                                <div class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-6">
                                    ${currentData.regular.map(item => `
                                        <div class="tech-box-bg rounded-xl overflow-hidden shadow-xl border border-gray-700 content-transition hover:border-gray-500 transition duration-200 group">
                                            <a href="${item.imageUrl}" target="_blank" class="block">
                                                <img src="${item.imageUrl}" alt="${currentData.type}" class="w-full h-48 object-cover object-center transform group-hover:scale-105 transition-transform duration-300">
                                            </a>
                                            <div class="p-4 text-xs">
                                                <p class="text-gray-400 mb-2">Uploaded by: ${item.uploadedBy}</p>
                                                <div class="flex flex-col space-y-2">
                                                    <a href="${item.imageUrl}" download class="flex items-center justify-center gap-1.5 w-full bg-gray-700 text-white px-3 py-1.5 text-xs rounded-lg font-semibold hover:bg-gray-600 transition shadow-md">
                                                        ${icons.Download(16)} DOWNLOAD
                                                    </a>
                                                    ${this.state.isAdmin ? `
                                                        <button data-promote="${item.id}" data-type="${currentData.type}" class="flex items-center justify-center gap-1.5 w-full admin-gradient text-white px-3 py-1.5 text-xs rounded-lg font-semibold hover:shadow-cyan-500/80 transition shadow-md transform hover:scale-[1.02]">
                                                            ${icons.Heart(16)} PROMOTE
                                                        </button>
                                                        <button data-delete-item="${item.id}" data-type="${currentData.type}" class="flex items-center justify-center gap-1.5 w-full bg-red-700 text-white px-3 py-1.5 text-xs rounded-lg font-semibold hover:bg-red-800 transition shadow-md">
                                                            ${icons.Trash(16)} DELETE
                                                        </button>
                                                    ` : ''}
                                                </div>
                                            </div>
                                        </div>
                                    `).join('')}
                                </div>
                            `}
                        </div>
                    </div>
                `;
            }

            // --- RENDER SCROLLING HALL OF FAME ---
            renderScrollingHallOfFame(items, type) {
                if (items.length === 0) {
                    return `
                        <div class="text-center py-12 tech-box-bg rounded-2xl shadow-lg"><p class="text-gray-400">No ${type}s in the Hall of Glory yet.</p></div>
                    `;
                }

                const containerId = type === 'meme' ? 'meme-scroll-container' : 'memory-scroll-container';
                const currentIndex = type === 'meme' ? this.state.memeScrollIndex : this.state.memoryScrollIndex;
                const totalItems = items.length;

                // Adjust index for display only (since scrolling is handled by CSS snap)
                const currentItem = items[currentIndex % totalItems];

                return `
                    <div class="relative">
                        <div id="${containerId}" class="scroll-container flex snap-x snap-mandatory overflow-x-hidden rounded-2xl shadow-2xl tech-border">
                            ${items.map((item, index) => `
                                <div class="snap-full flex-shrink-0 w-full h-96 relative hof-card rounded-2xl ${index === currentIndex ? '' : 'hidden'}" data-index="${index}" style="border-image: linear-gradient(45deg, ${type === 'meme' ? '#ff0077' : '#00f2ff'}, ${type === 'meme' ? '#aa00ff' : '#0077ff'}) 1;">
                                    <a href="${item.imageUrl}" target="_blank" class="block w-full h-full">
                                        <img src="${item.imageUrl}" alt="Hall of Fame ${type}" class="w-full h-full object-contain p-4 bg-[#1a1b26] rounded-2xl">
                                    </a>
                                    <div class="absolute bottom-0 left-0 right-0 bg-gradient-to-t from-black/80 to-transparent p-4">
                                        <p class="text-sm text-gray-300">Archive Entry: ${item.id}</p>
                                        <p class="text-xs text-gray-500">Source: ${item.uploadedBy}</p>
                                    </div>
                                    ${this.state.isAdmin ? `
                                        <button data-remove-hof="${item.id}" data-type="${type}" class="absolute top-4 right-4 bg-red-700 text-white px-3 py-1.5 text-xs rounded-xl font-semibold hover:bg-red-800 shadow-md transition transform hover:scale-[1.05]">
                                            REMOVE
                                        </button>
                                    ` : ''}
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
            }

            // --- CMatrix helper function ---
            renderCMatrix() {
                CMatrix.start();
                return '';
            }

            // --- RENDER LOGIN MODAL ---
            renderLoginModal() {
                return `
                    ${this.renderCMatrix()}
                    <div class="fixed inset-0 bg-gray-900 bg-opacity-95 backdrop-blur-md flex items-center justify-center z-50">
                        <div class="bg-[#1a1b26] rounded-3xl shadow-2xl shadow-cyan-500/50 p-6 sm:p-10 w-11/12 max-w-md relative transform transition-all scale-100 duration-300 tech-border border-[#00f2ff] animate-pulse-shadow">
                            <button id="closeLogin" class="absolute top-5 right-5 text-gray-400 hover:text-[#00f2ff] text-3xl transition z-10">‚úï</button>
                            <div class="text-center mb-10">
                                <h1 class="text-4xl font-extrabold neon-text-cyan mb-2 tracking-widest">LOGIN_INTERFACE</h1>
                                <p class="text-gray-500 text-lg">Input Hub Credentials.</p>
                            </div>
                            <form id="loginForm" class="space-y-6">
                                <div>
                                    <label class="block text-sm font-bold text-[#00f2ff] mb-2">// EMAIL_ID</label>
                                    <input id="emailInput" type="email" value="${this.state.email}" placeholder="bt25cshXXX@iiitn.ac.in" class="w-full px-4 py-3 bg-[#111219] text-white rounded-lg border border-gray-700 focus:border-[#00f2ff] focus:ring focus:ring-[#00f2ff]/30 transition" required>
                                </div>
                                <div>
                                    <label class="block text-sm font-bold text-[#ff0077] mb-2">// ACCESS_KEY</label>
                                    <input id="passwordInput" type="password" value="${this.state.password}" placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢" class="w-full px-4 py-3 bg-[#111219] text-white rounded-lg border border-gray-700 focus:border-[#ff0077] focus:ring focus:ring-[#ff0077]/30 transition" required>
                                </div>
                                ${this.state.error ? `
                                    <p class="text-red-500 text-center font-bold bg-red-900/30 p-2 rounded-lg">${this.state.error}</p>
                                ` : ''}
                                <button type="submit" class="w-full admin-gradient text-white px-4 py-3 rounded-xl font-extrabold text-xl flex items-center justify-center gap-2 shadow-lg hover:shadow-cyan-500/80 transition transform hover:scale-[1.015]">
                                    ACCESS // GRANTED
                                </button>
                            </form>
                            ${this.state.uploadStatus ? `
                                <div class="mt-6 bg-[#00f2ff]/20 border-l-4 border-[#00f2ff] text-white p-3 rounded-lg shadow-md font-bold" role="alert">
                                    <p class="text-xs text-[#00f2ff]">// STATUS</p>
                                    <p class="text-sm">${this.state.uploadStatus}</p>
                                </div>
                            ` : ''}
                        </div>
                    </div>
                `;
            }

            render() {
                const root = document.getElementById('root');
                if (this.state.showLogin) {
                    root.innerHTML = this.renderLoginModal();
                } else {
                    CMatrix.stop(); // Ensure matrix is stopped if not on login
                    root.innerHTML = this.renderMainPage();
                }
                this.attachEventListeners();

                // CRITICAL: Auto-scroll must be triggered *after* the DOM is updated 
                // but should not be called in a loop that triggers render.
                requestAnimationFrame(() => {
                    if (this.state.currentTab === 'memes' && !this.state.showLogin) {
                        this.updateScrollPosition('meme');
                    }
                    if (this.state.currentTab === 'memories' && !this.state.showLogin) {
                        this.updateScrollPosition('memory');
                    }
                });
            }

            // --- SCROLLING LOGIC ---
            updateScrollPosition(type) {
                const containerId = type === 'meme' ? 'meme-scroll-container' : 'memory-scroll-container';
                const container = document.getElementById(containerId);
                const items = type === 'meme' ? this.state.hallOfFameMemes : this.state.hallOfFameMemories;
                const currentIndex = type === 'meme' ? this.state.memeScrollIndex : this.state.memoryScrollIndex;

                if (!container || items.length === 0) return;

                // CRITICAL FIX: Direct DOM manipulation for scrolling
                const width = container.offsetWidth;
                container.scrollLeft = width * (currentIndex % items.length);
            }


            scrollMemes(direction) {
                const container = document.getElementById('meme-scroll-container');
                if (!container || this.state.hallOfFameMemes.length === 0) return;
                const totalItems = this.state.hallOfFameMemes.length;
                let newIndex = this.state.memeScrollIndex;

                if (direction === 'next') {
                    newIndex = (newIndex + 1) % totalItems;
                } else if (direction === 'prev') {
                    newIndex = (newIndex - 1 + totalItems) % totalItems;
                }

                if (this.state.memeScrollIndex !== newIndex) {
                    this.state.memeScrollIndex = newIndex;
                    // CRITICAL FIX: Direct DOM manipulation for scrolling
                    const width = container.offsetWidth;
                    container.scrollLeft = width * newIndex;
                }
            }

            scrollMemories(direction) {
                const container = document.getElementById('memory-scroll-container');
                if (!container || this.state.hallOfFameMemories.length === 0) return;
                const totalItems = this.state.hallOfFameMemories.length;
                let newIndex = this.state.memoryScrollIndex;

                if (direction === 'next') {
                    newIndex = (newIndex + 1) % totalItems;
                } else if (direction === 'prev') {
                    newIndex = (newIndex - 1 + totalItems) % totalItems;
                }

                if (this.state.memoryScrollIndex !== newIndex) {
                    this.state.memoryScrollIndex = newIndex;
                    // CRITICAL FIX: Direct DOM manipulation for scrolling
                    const width = container.offsetWidth;
                    container.scrollLeft = width * newIndex;
                }
            }

            startAutoScroll() {
               // Ensure intervals are cleared on startup
                if (this.memeScrollInterval) clearInterval(this.memeScrollInterval);
                this.memeScrollInterval = setInterval(() => {
                    if (this.state.currentTab === 'memes' && !this.state.showLogin) {
                        this.scrollMemes('next'); // Calls direct DOM update
                    }
                }, 5000);

                if (this.memoryScrollInterval) clearInterval(this.memoryScrollInterval);
                this.memoryScrollInterval = setInterval(() => {
                    if (this.state.currentTab === 'memories' && !this.state.showLogin) {
                        this.scrollMemories('next'); // Calls direct DOM update
                    }
                }, 5000);
            }
            // --- END SCROLLING LOGIC ---


            // --- EVENT LISTENERS ---
            attachEventListeners() {
                // Login/Logout
                const showLoginBtn = document.getElementById('showLoginBtn');
                if (showLoginBtn) showLoginBtn.onclick = () => { this.state.showLogin = true; this.render(); };
                const closeLoginBtn = document.getElementById('closeLogin');
                if (closeLoginBtn) closeLoginBtn.onclick = () => { this.state.showLogin = false; this.state.error = ''; this.state.uploadStatus = ''; this.render(); };
                const loginForm = document.getElementById('loginForm');
                if (loginForm) loginForm.onsubmit = (e) => this.handleLogin(e);
                const logoutBtn = document.getElementById('logoutBtn');
                if (logoutBtn) logoutBtn.onclick = () => this.handleLogout();

                // Admin Wipe
                const adminWipeBtn = document.getElementById('adminWipeBtn');
                if (adminWipeBtn) adminWipeBtn.onclick = () => this.handleWipeAndArchive();

                // Admin Notice Post
                const postNoticeForm = document.getElementById('postNoticeForm');
                if (postNoticeForm) postNoticeForm.onsubmit = (e) => this.handlePostNotice(e);

                // Inputs
                const emailInput = document.getElementById('emailInput');
                if (emailInput) emailInput.oninput = (e) => { this.state.email = e.target.value; };
                const passwordInput = document.getElementById('passwordInput');
                if (passwordInput) passwordInput.oninput = (e) => { this.state.password = e.target.value; };
                const fileInput = document.getElementById('fileInput');
                if (fileInput) fileInput.onchange = (e) => this.handleFileUpload(e.target.files[0], this.state.currentTab === 'memories' ? 'memory' : 'meme');

                // Tab switching logic for animation
                document.querySelectorAll('[data-tab]').forEach(btn => {
                    btn.onclick = () => {
                        const newTab = btn.getAttribute('data-tab');
                        if (this.state.currentTab !== newTab) {
                            // Apply transition class to main content before switching
                            const mainContent = document.querySelector('.max-w-7xl');
                            if (mainContent) {
                                mainContent.classList.remove('content-transition');
                            }
                            
                            this.state.currentTab = newTab;
                            this.render();

                            // Re-apply transition class after a short delay for next render
                            requestAnimationFrame(() => {
                                const newContent = document.querySelector('.max-w-7xl') || document.getElementById('notices-content');
                                if (newContent) {
                                    newContent.classList.add('content-transition');
                                }
                            });
                        }
                    };
                });
                
                // Admin Actions: Promote/Delete
                document.querySelectorAll('[data-promote]').forEach(btn => {
                    btn.onclick = () => {
                        const id = parseInt(btn.getAttribute('data-promote'));
                        const type = btn.getAttribute('data-type');
                        const item = type === 'meme' 
                            ? this.state.memes.find(m => m.id === id) 
                            : this.state.memories.find(m => m.id === id);
                        if (item) this.promoteToHallOfFame(item, type);
                    };
                });

                document.querySelectorAll('[data-remove-hof]').forEach(btn => {
                    btn.onclick = () => {
                        const id = parseInt(btn.getAttribute('data-remove-hof'));
                        const type = btn.getAttribute('data-type');
                        this.removeFromHallOfFame(id, type);
                    };
                });

                document.querySelectorAll('[data-delete-item]').forEach(btn => {
                    btn.onclick = () => {
                        const id = parseInt(btn.getAttribute('data-delete-item'));
                        const type = btn.getAttribute('data-type');
                        if (confirm(`Are you sure you want to delete this ${type} forever?`)) {
                            this.handleDeleteItem(id, type);
                        }
                    };
                });

                document.querySelectorAll('[data-delete-notice]').forEach(btn => {
                    btn.onclick = () => {
                        const id = parseInt(btn.getAttribute('data-delete-notice'));
                        if (confirm(`Are you sure you want to delete this notice?`)) {
                            this.handleDeleteNotice(id);
                        }
                    };
                });

                // Manual Scroll Controls
                document.querySelectorAll('[data-scroll]').forEach(btn => {
                    btn.onclick = () => {
                        const type = btn.getAttribute('data-scroll');
                        const direction = btn.getAttribute('data-direction');
                        if (type === 'meme') {
                            this.scrollMemes(direction);
                        } else if (type === 'memory') {
                            this.scrollMemories(direction);
                        }
                    };
                });
            }
        }

        // --- Defer initialization until the DOM is ready ---
        document.addEventListener('DOMContentLoaded', () => {
            new MemeGallery();
        });
    </script>
</body>
</html>
